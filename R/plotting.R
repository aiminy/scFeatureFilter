#' Plotting the results.
#'
#' This set of functions generate the summary plots that result from the correlation-based
#' analysis of your single-cell sequencing data.
#' 
#' Each plotting function is designed to plot the output data of another function in this
#' package. Associations are as follows:
#' 
#' \itemize{
#' 
#'      \item \code{plot_scatter} plots the output of the \code{\link{calculate_cvs}} 
#'      function, more specifically, only the \code{CV} and \code{mean} columns. However, 
#'      the plotting function selects these automatically, and the entire data frame 
#'      should be provided by the user when calling it. 
#'      
#'      If running \code{\link{all_calls}}, this can be done by subsetting the results 
#'      using \code{$cv}.
#'      
#'      \item \code{plot_bins} plots the output of the \code{\link{bin_scdata}} function.
#'      Similarly, the entire data frame should be provided, as the function will select 
#'      the \code{CV}, \code{mean} and \code{bin} columns automatically from it.
#'      
#'      Subset the appropriate results from \code{all_calls} using \code{$binned}.
#'      
#'       \item \code{plot_cor_dens} plots the output of the \code{\link{compute_density}} 
#'       function.It should be noted that this function outputs the density computations 
#'       for only one window, and therefore, the plotting function must be called again 
#'       after each computation. 
#'       
#'       Subset the appropriate results from \code{all_calls} using 
#'       \code{$densities[[window number]]}.
#'       
#'       \item \code{plot_histogram} plots the output of the \code{\link{compute_histogram}} 
#'       function. Subset \code{all_calls} results using \code{$histogram}.
#' }
#' 
#' For the \code{...} argument:
#' 
#' \itemize{
#' 
#'      \item \code{plot_scatter} and \code{plot_bins} pass on the arguments to the 
#'      \code{geom_point} function in \code{ggplot2}.
#'      
#'       \item \code{plot_cor_dens} passes arguments on to the \code{geom_line} function in
#'       \code{ggplot2}.
#'       
#'       \item \code{plot_histogram} passes arguments on to \code{geom_bar} function in 
#'       \code{ggplot2}.
#' }
#' 
#' For suitable aesthetics, please see documentation of these functions.
#' 
#' \strong{Important note:} calling the plotting functions doesn't enable visualization of
#' the plot. The plot list that is generated should be saved and then visualized by calling the
#' \code{plot} function on it.
#'
#' @param data A data frame containing the suitably formatted data for the specified plot.
#' 
#' @param save A logical. When \code{TRUE}, plots will be saved to the indicated path.
#' 
#' @param display A logical. When \code{TRUE}, plots will be displayed.
#' 
#' @param path A string indicating a path to save the plot to. 
#' 
#' @param filename A string indicating the name of the plot file.
#' 
#' @param format A string indicating the file format of the plot.
#' 
#' @param density Logical. Specifies whether the scatter plot will incorporate scatter
#' density lines.
#' 
#' @param shape, size, alpha Numbers specifying aesthetics of the scatter plots, passed on
#' to the \code{geom_point} function in the \code{ggplot2} package. Shape is an integer, 
#' size and alpha are doubles.
#' 
#' @param ... Other aesthetic specifications to be passed on to the \code{geom_point}, 
#' \code{geom_line} or \code{geom_bar} functions.
#' 
#' @param window An integer. Indicates the window for which the correlation density plot
#' is being generated by \code{plot_cor_dens}.
#' 
#' @param ribbon_col, ribbon_alpha Aesthetics for the error space in the correlation density
#' plot. Color indicated by a string, and alpha indicated by a double.
#' 
#' @param curve_cols A string vector. Specifies colours of the negative control and data 
#' curves in the correlation density plots, in that order.
#' 
#' @param title A string. Contains the title to be set on the histogram plot, normally an
#' informative title. Recommendation is to specify top window method of selection and size, 
#' number and size of bins, number of cells in the original dataset.
#' 
#' @param ylim A double. Sets the limit of the y axis.
#' 
#' @return A list, containing the information of the generated plot.

plot_mean_variance <- function(df, density = FALSE, colourByBin = TRUE, ...){
    if(colourByBin) {
        pl <- ggplot(df, aes(x = cv, y = mean + 1, colour = factor(bin))) +
            labs(x ="Coefficient of variation", y = "Mean expression + 1" , color = "Bin") 
        
    } else {
        pl <- ggplot(df, aes(x = cv, y = mean + 1)) +
            labs(x ="Coefficient of variation", y = "Mean expression + 1") 
        
    }
    
    pl <- pl +
        geom_point(...) +
        scale_y_log10()
    # add scatter density to plot
    if (density == TRUE) {
        pl <- pl + geom_density_2d()
    }
    
    return(pl)
}


plot_correlations_distributions <- function(df, metrics = NULL, vlines = c("median", "mean"), facet_ncol = 4) {
    
    vlines <- match.arg(vlines)
    
    pl <- ggplot() +
        geom_smooth(data = dplyr::filter(df, window != "top_window"), aes(x = cor_coef, y = density), span = 0.8) +
        geom_line(  data = dplyr::filter(df, window == "top_window"), aes(x = cor_coef, y = density, color = factor(bin))) +
        facet_wrap(~bin, labeller = "label_both", ncol = facet_ncol) +
        labs(x = "correlation coeficient") +
        guides(color = FALSE)
    if (!is.null(metrics)) {
        
        metrics <- dplyr::select_(metrics, "bin", "window", vlines) %>%
            rename_(metric = vlines) %>%
            mutate(window = sub("_[0-9]+$", "", window)) %>%
            group_by(bin, window) %>%
            summarise(metric = median(abs(metric)))
        
        pl <- pl + 
            geom_vline(
                data = dplyr::filter(metrics, window == "top_window"),
                aes(xintercept = metric, color = factor(bin)),
                linetype = "dashed"
            ) +
            geom_vline(
                data = dplyr::filter(metrics, window != "top_window"),
                aes(xintercept = metric),
                linetype = "dashed"
            ) 
    }
    
    return(pl)
}

plot_metric <- function(metricsTable, metric = c("median", "mean")) {
    
    metric <- match.arg(metric)
    
    metricsTable <- data_frame(
        bin = unique(metricsTable$bin),
        top_window = dplyr::filter(metricsTable, window == "top_window") %>%
            dplyr::select_(metric) %>%
            unlist,
        ctrl_window_median = dplyr::filter(metricsTable, window != "top_window") %>%
            dplyr::rename_(metric = metric) %>%
            dplyr::select(bin, metric) %>%
            dplyr::group_by(bin) %>%
            dplyr::summarise(med = median(metric)) %>%
            select(med) %>%
            unlist,
        ctrl_window_sd = dplyr::filter(metricsTable, window != "top_window") %>%
            dplyr::rename_(metric = metric) %>%
            dplyr::select(bin, metric) %>%
            dplyr::group_by(bin) %>%
            dplyr::summarise(med = sd(metric)) %>%
            select(med) %>%
            unlist,
        diff = top_window - ctrl_window_median
    ) 
    
    p <- ggplot(metricsTable, aes(x = bin, y = diff, fill = factor(bin))) +
        geom_bar(stat = "identity") +
        geom_errorbar(aes(ymin = diff - ctrl_window_sd, ymax = diff + ctrl_window_sd), width = 0.5) +
        guides(fill = FALSE) +
        labs(ylab = "Actual - randomisation")
    
}