# take a bottom window, a top window, and return a vector of correlation values
.correlate_window <- function(topMatrix, bottomMatrix, ...) {
    correlations <- list()
    for(j in seq_len(nrow(topMatrix))){
        correlations[[j]] <- cor(topMatrix[j,], t(bottomMatrix), ...) %>% as.vector
    }
    return(do.call(c, correlations))
}


#' Calculate correlations against top window.
#'
#' Calculates correlations of each window against the top, and stores them in a vector.
#'
#' The input of this function is usually the output of the \code{\link{bin_scdata}} function.
#'
#' The correlation vector for each window is generated by iterating the genes in the top window
#' and correlating them to every other window. As a result, there will be as many correlation
#' values in the vector as genes in the top window. Consequently, top window size greatly impacts
#' the computational efficiency of the process.
#'
#' The correlation method argument is passed on to the \code{cor} function, in the \code{stats}
#' package, and therefore, the same options as this function provides are available. However, it
#' is adviseable to use pearson correlation, since it presents the most advantageous balance of
#' result quality and computational efficiency.
#'
#' @param dataset A data frame containing all the binned genes.
#'
#' @param cor_method A string indicating the type of correlation to use.
#'
#' @return A list containing, on a separate element, the vectors of correlations for every
#' window against the top.


correlate_windows <- function(dataset, n_random = 10, ...){

    # extract the top window genes
    top_window <- dplyr::filter(dataset, bin == 1) %>%
        dplyr::select(-geneName, -mean, -sd, -cv, -bin) %>% 
        as.matrix
    if(ncol(top_window) <= 1) stop("Needs more than 1 cell!")
    shuffled_top_windows <- lapply(
        seq_len(n_random),
        function(x) t(apply(top_window, 1, sample))
    )
    
    # iterate bins in the dataset
    corTable <- bind_rows(
        lapply(
            unique(dataset$bin),
            function(i) {
                # select the genes in the chosen window using the bin number
                selected_window <- dplyr::filter(dataset, bin == i) %>%
                    dplyr::select(-geneName, -mean, -sd, -cv, -bin) %>%
                    as.matrix
                
                with_top_window <- data_frame(
                    bin = i,
                    window = "top_window",
                    cor_coef = .correlate_window(top_window, selected_window)
                )
                
                with_controls <- bind_rows(
                    lapply(
                        seq_len(n_random),
                        function(j) {
                            data_frame(
                                bin = i,
                                window = paste0("shuffled_top_window_", j),
                                cor_coef = .correlate_window(shuffled_top_windows[[j]], selected_window)
                            )
                        }
                    )
                )
                
                return(bind_rows(with_top_window, with_controls))
            }
            
        )
    )
    # by_bin_correlations <- list()
    # for(i in unique(dataset$bin)){
    #     by_bin_correlations[[i]] <- list()
    #     # select the genes in the chosen window using the bin number
    #     selected_window <- dplyr::filter(dataset, bin == i) %>%
    #         dplyr::select(-geneName, -mean, -sd, -cv, -bin) %>%
    #         as.matrix
    #     
    #     # by_bin_correlations[[i]]$with_top_window <- .correlate_window(top_window, selected_window)
    #     # by_bin_correlations[[i]]$with_randoms <- list()
    #     # for(j in seq_len(n_random)) {
    #     #     by_bin_correlations[[i]]$with_randoms[[j]] <- .correlate_window(shuffled_top_windows[[j]], selected_window)
    #     # }
    #     
    # }
    
    return(corTable)
}
